#include "../TriangulationTable/TriangulationLookuptable.hlsl"
#pragma kernel MarchCubes

float _Threshold;

float3 _WorldPos;


StructuredBuffer<float> _Values;

struct Triangle
{
    float3 a, b, c;
};

AppendStructuredBuffer<Triangle> _Trinagles;



float3 interpolation(float3 p1, float3 value1, float3 p2, float value2)
{
    return (p1 + (_Threshold-value1) * (p2 - p1) / (value2 - value1));
}


[numthreads(8, 8, 1)]
void MarchCubes(uint3 id : SV_DispatchThreadID)
{
    float cubeValues[8];
    cubeValues[0] = _Values[id.x + id.y * 8 + id.z * 64];
    cubeValues[1] = _Values[id.x + 1 + id.y * 8 + id.z * 64];
    cubeValues[2] = _Values[id.x + 1 + (id.y + 1) * 8 + id.z * 64];
    cubeValues[3] = _Values[id.x + (id.y + 1) * 8 + id.z * 64];
    cubeValues[4] = _Values[id.x + id.y * 8 + (id.z + 1) * 64];
    cubeValues[5] = _Values[id.x + 1 + id.y * 8 + (id.z + 1) * 64];
    cubeValues[6] = _Values[id.x + 1 + (id.y + 1) * 8 + (id.z + 1) * 64];
    cubeValues[7] = _Values[id.x + (id.y + 1) * 8 + (id.z + 1) * 64];
    
    int cubeIndex = 0;
    if (cubeValues[0] < _Threshold)
        cubeIndex |= 1;
    if (cubeValues[1] < _Threshold)
        cubeIndex |= 2;
    if (cubeValues[2] < _Threshold)
        cubeIndex |= 4;
    if (cubeValues[3] < _Threshold)
        cubeIndex |= 8;
    if (cubeValues[4] < _Threshold)
        cubeIndex |= 16;
    if (cubeValues[5] < _Threshold)
        cubeIndex |= 32;
    if (cubeValues[6] < _Threshold)
        cubeIndex |= 64;
    if (cubeValues[7] < _Threshold)
        cubeIndex |= 128;
    
    int edges[] = triTable[cubeIndex];

    for (int i = 0; edges[i]; i += 3)
    {
        int edge00 = edgeConnections[edges[i]][0];
        int edge01 = edgeConnections[edges[i]][1];
        
        int edge10 = edgeConnections[edges[i + 1]][0];
        int edge11 = edgeConnections[edges[i + 1]][1];
        
        int edge20 = edgeConnections[edges[i + 2]][0];
        int edge21 = edgeConnections[edges[i + 2]][1];
        
        Triangle tri;
        
        tri.a = interpolation(cornerOffsets[edge00], cubeValues[edge00], cornerOffsets[edge01], cubeValues[edge01]) + _WorldPos;
        tri.b = interpolation(cornerOffsets[edge10], cubeValues[edge10], cornerOffsets[edge11], cubeValues[edge11]) + _WorldPos;
        tri.c = interpolation(cornerOffsets[edge20], cubeValues[edge20], cornerOffsets[edge21], cubeValues[edge21]) + _WorldPos;
    }
    
}
